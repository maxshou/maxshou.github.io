<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
  <title>Max&#39;s blog</title>
  <meta name="description" content="流云借风" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="MobileOptimized" content="320" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <link rel="stylesheet" type="text/css" href="/css/screen.css" />
  <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Noto+Serif:400,700,400italic|Open+Sans:700,400" />

  <meta name="generator" content="Max's blog">

  
  
  

  
</head>


<body class="home-template">

  <header class="site-head"  style="background-image: url(https://7672-vride-id-1302852934.tcb.qcloud.la/images/background.jpg?sign=45aed964f34ac38dd34aa6cf97887958&t=1611041477)" >
    <div class="vertical">
        <div class="site-head-content inner">
             <a class="blog-logo" href="/"><img src="https://7672-vride-id-1302852934.tcb.qcloud.la/images/logo.png?sign=73b7b80e989477f03e9cc84872e9d5d7&t=1611044870" alt="Blog Logo"/></a> 
            <h1 class="blog-title">Max's blog</h1>
            <h2 class="blog-description">流云借风</h2>
        </div>
    </div>
</header>
  
<main class="content" role="main">
  
  <article class="post">
    <header class="post-header">
      <span class="post-meta">
      <time datetime="2021-08-05T08:01:13.817Z" itemprop="datePublished">
          2021-08-05
      </time>
    
</span>
      <h2 class="post-title"><a href="/2021/08/05/671. 二叉树中第二小的节点/"></a></h2>
    </header>
    <section class="post-excerpt">
      <p>
      
        671. 二叉树中第二小的节点难度简单
给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个。
更正式地说，root.val = min(root.left.val, root.right.val) 总成立。
给出这样的一个二叉树，你需要输出所有节点中的第二小的值。如果第二小的值不存在的话，输出 -1 。
示例 1：

123输入：
      
      </p>
      
      <p>
          <a href="/2021/08/05/671. 二叉树中第二小的节点/" class="excerpt-link">Read More...</a>
      </p>
      
    </section>
  </article>
  
  <article class="post">
    <header class="post-header">
      <span class="post-meta">
      <time datetime="2021-08-05T08:01:13.807Z" itemprop="datePublished">
          2021-08-05
      </time>
    
</span>
      <h2 class="post-title"><a href="/2021/08/05/581. 最短无序连续子数组/"></a></h2>
    </header>
    <section class="post-excerpt">
      <p>
      
        581. 最短无序连续子数组难度中等
给你一个整数数组 nums ，你需要找出一个 连续子数组 ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。
请你找出符合题意的 最短 子数组，并输出它的长度。
示例 1：
123输入：nums &#x3D; [2,6,4,8,10,9,15]输出：5解释：你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。
示例 2：
12输入：nums &#x3D
      
      </p>
      
      <p>
          <a href="/2021/08/05/581. 最短无序连续子数组/" class="excerpt-link">Read More...</a>
      </p>
      
    </section>
  </article>
  
  <article class="post">
    <header class="post-header">
      <span class="post-meta">
      <time datetime="2021-08-05T08:01:13.791Z" itemprop="datePublished">
          2021-08-05
      </time>
    
</span>
      <h2 class="post-title"><a href="/2021/08/05/560. 和为K的子数组/"></a></h2>
    </header>
    <section class="post-excerpt">
      <p>
      
        560. 和为K的子数组给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。
示例 1 :
12输入:nums &#x3D; [1,1,1], k &#x3D; 2输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。
说明 :

数组的长度为 [1, 20,000]。
数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。

1. 暴力算法时间复杂度O(n
      
      </p>
      
      <p>
          <a href="/2021/08/05/560. 和为K的子数组/" class="excerpt-link">Read More...</a>
      </p>
      
    </section>
  </article>
  
  <article class="post">
    <header class="post-header">
      <span class="post-meta">
      <time datetime="2021-08-05T08:01:13.778Z" itemprop="datePublished">
          2021-08-05
      </time>
    
</span>
      <h2 class="post-title"><a href="/2021/08/05/394. 字符串解码/"></a></h2>
    </header>
    <section class="post-excerpt">
      <p>
      
        394. 字符串解码123456789101112131415161718192021222324252627282930313233343536public string DecodeString(string s)        &#123;            LinkedList&lt;int&gt; numberStack &#x3D; new LinkedList&lt;int&gt;();            Link
      
      </p>
      
      <p>
          <a href="/2021/08/05/394. 字符串解码/" class="excerpt-link">Read More...</a>
      </p>
      
    </section>
  </article>
  
  <article class="post">
    <header class="post-header">
      <span class="post-meta">
      <time datetime="2021-08-05T08:01:13.768Z" itemprop="datePublished">
          2021-08-05
      </time>
    
</span>
      <h2 class="post-title"><a href="/2021/08/05/236. 二叉树的最近公共祖先/"></a></h2>
    </header>
    <section class="post-excerpt">
      <p>
      
        236. 二叉树的最近公共祖先给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

12345678910示例 1:输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x
      
      </p>
      
      <p>
          <a href="/2021/08/05/236. 二叉树的最近公共祖先/" class="excerpt-link">Read More...</a>
      </p>
      
    </section>
  </article>
  
  <article class="post">
    <header class="post-header">
      <span class="post-meta">
      <time datetime="2021-08-05T08:01:13.754Z" itemprop="datePublished">
          2021-08-05
      </time>
    
</span>
      <h2 class="post-title"><a href="/2021/08/05/221. 最大正方形/"></a></h2>
    </header>
    <section class="post-excerpt">
      <p>
      
        221. 最大正方形在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。
示例:
12345678输入: 1 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0输出: 4
动态规划
若形成正方形（非单 1），以当前为右下角的视角看，则需要：当前格、上、左、左上都是 1
可以换个角度：当前格、上、左、左上都不能受 0 的限制，才能成为正方形


当前格可形成的大小可化简为当前格的左上、左、
      
      </p>
      
      <p>
          <a href="/2021/08/05/221. 最大正方形/" class="excerpt-link">Read More...</a>
      </p>
      
    </section>
  </article>
  
  <article class="post">
    <header class="post-header">
      <span class="post-meta">
      <time datetime="2021-08-05T08:01:13.740Z" itemprop="datePublished">
          2021-08-05
      </time>
    
</span>
      <h2 class="post-title"><a href="/2021/08/05/155. 最小栈/"></a></h2>
    </header>
    <section class="post-excerpt">
      <p>
      
        155. 最小栈设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。

push(x) —— 将元素 x 推入栈中。
pop() —— 删除栈顶的元素。
top() —— 获取栈顶元素。
getMin() —— 检索栈中的最小元素。

12345678910111213141516输入：[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&qu
      
      </p>
      
      <p>
          <a href="/2021/08/05/155. 最小栈/" class="excerpt-link">Read More...</a>
      </p>
      
    </section>
  </article>
  
  <article class="post">
    <header class="post-header">
      <span class="post-meta">
      <time datetime="2021-08-05T08:01:13.725Z" itemprop="datePublished">
          2021-08-05
      </time>
    
</span>
      <h2 class="post-title"><a href="/2021/08/05/136. 只出现一次的数字/"></a></h2>
    </header>
    <section class="post-excerpt">
      <p>
      
        136. 只出现一次的数字给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
说明：
你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？
12345678示例 1:输入: [2,2,1]输出: 1示例 2:输入: [4,1,2,1,2]输出: 4
思路：

使用暴力算法，时间复杂度O(n²)

使用排序，复杂度O(n*log(n))

使用哈希表，需要空间来存储之前的数，
      
      </p>
      
      <p>
          <a href="/2021/08/05/136. 只出现一次的数字/" class="excerpt-link">Read More...</a>
      </p>
      
    </section>
  </article>
  
  <article class="post">
    <header class="post-header">
      <span class="post-meta">
      <time datetime="2021-08-05T08:01:13.716Z" itemprop="datePublished">
          2021-08-05
      </time>
    
</span>
      <h2 class="post-title"><a href="/2021/08/05/121. 买卖股票的最佳时机/"></a></h2>
    </header>
    <section class="post-excerpt">
      <p>
      
        121. 买卖股票的最佳时机给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。
注意：你不能在买入股票前卖出股票。
示例 1:
输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。     注意利润不能是 
      
      </p>
      
      <p>
          <a href="/2021/08/05/121. 买卖股票的最佳时机/" class="excerpt-link">Read More...</a>
      </p>
      
    </section>
  </article>
  
  <article class="post">
    <header class="post-header">
      <span class="post-meta">
      <time datetime="2021-08-05T08:01:13.697Z" itemprop="datePublished">
          2021-08-05
      </time>
    
</span>
      <h2 class="post-title"><a href="/2021/08/05/102. 二叉树的层序遍历/"></a></h2>
    </header>
    <section class="post-excerpt">
      <p>
      
        102. 二叉树的层序遍历给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。
示例：二叉树：[3,9,20,null,null,15,7],
123456789101112    3   &#x2F; \  9  20    &#x2F;  \   15   7返回其层次遍历结果：[  [3],  [9,20],  [15,7]]


广度优先BFS思路：遍历每一层，然后将每层的数值存入List
      
      </p>
      
      <p>
          <a href="/2021/08/05/102. 二叉树的层序遍历/" class="excerpt-link">Read More...</a>
      </p>
      
    </section>
  </article>
  
  <nav class="pagination" role="pagination">
    
    <span class="page-number">Page 1 of 4</span>
    <a class="older-posts" href="/page/2/">Older Posts →</a>
  </nav>
</main>


  
<footer class="site-footer">
  
  <div class="inner">
     <section class="copyright">All content copyright <a href="/">Max's blog</a> &copy; 2014 &bull; All rights reserved.</section>
     <section class="poweredby">Proudly published with <a class="icon-ghost" target="_blank" rel="noopener" href="http://zespia.tw/hexo/">Hexo</a></section>
  </div>
</footer>

  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>

<script type="text/javascript" src="/js/jquery.fitvids.js"></script>
<script type="text/javascript" src="/js/index.js"></script>






</body>
</html>
