<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
  <title>Archives | Max&#39;s blog</title>
  <meta name="description" content="流云借风" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="MobileOptimized" content="320" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <link rel="stylesheet" type="text/css" href="/css/screen.css" />
  <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Noto+Serif:400,700,400italic|Open+Sans:700,400" />

  <meta name="generator" content="Max's blog">

  
  
  

  
</head>


<body class="home-template">

  <header class="site-head"  style="background-image: url(https://7672-vride-id-1302852934.tcb.qcloud.la/images/background.jpg?sign=45aed964f34ac38dd34aa6cf97887958&t=1611041477)" >
    <div class="vertical">
        <div class="site-head-content inner">
             <a class="blog-logo" href="/"><img src="https://7672-vride-id-1302852934.tcb.qcloud.la/images/logo.png?sign=73b7b80e989477f03e9cc84872e9d5d7&t=1611044870" alt="Blog Logo"/></a> 
            <h1 class="blog-title">Max's blog</h1>
            <h2 class="blog-description">流云借风</h2>
        </div>
    </div>
</header>
  
<main class="content" role="main">
  
  <article class="post">
    <header class="post-header">
      <span class="post-meta">
      <time datetime="2021-08-05T08:01:13.817Z" itemprop="datePublished">
          2021-08-05
      </time>
    
</span>
      <h2 class="post-title"><a href="/2021/08/05/671. 二叉树中第二小的节点/"></a></h2>
    </header>
    <section class="post-excerpt">
      <p>
      
        671. 二叉树中第二小的节点难度简单
给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个。
更正式地说，root.val = min(root.left.val, root.right.val) 总成立。
给出这样的一个二叉树，你需要输出所有节点中的第二小的值。如果第二小的值不存在的话，输出 -1 。
示例 1：

123输入：
      
      </p>
      
      <p>
          <a href="/2021/08/05/671. 二叉树中第二小的节点/" class="excerpt-link">Read More...</a>
      </p>
      
    </section>
  </article>
  
  <article class="post">
    <header class="post-header">
      <span class="post-meta">
      <time datetime="2021-08-05T08:01:13.807Z" itemprop="datePublished">
          2021-08-05
      </time>
    
</span>
      <h2 class="post-title"><a href="/2021/08/05/581. 最短无序连续子数组/"></a></h2>
    </header>
    <section class="post-excerpt">
      <p>
      
        581. 最短无序连续子数组难度中等
给你一个整数数组 nums ，你需要找出一个 连续子数组 ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。
请你找出符合题意的 最短 子数组，并输出它的长度。
示例 1：
123输入：nums &#x3D; [2,6,4,8,10,9,15]输出：5解释：你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。
示例 2：
12输入：nums &#x3D
      
      </p>
      
      <p>
          <a href="/2021/08/05/581. 最短无序连续子数组/" class="excerpt-link">Read More...</a>
      </p>
      
    </section>
  </article>
  
  <article class="post">
    <header class="post-header">
      <span class="post-meta">
      <time datetime="2021-08-05T08:01:13.791Z" itemprop="datePublished">
          2021-08-05
      </time>
    
</span>
      <h2 class="post-title"><a href="/2021/08/05/560. 和为K的子数组/"></a></h2>
    </header>
    <section class="post-excerpt">
      <p>
      
        560. 和为K的子数组给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。
示例 1 :
12输入:nums &#x3D; [1,1,1], k &#x3D; 2输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。
说明 :

数组的长度为 [1, 20,000]。
数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。

1. 暴力算法时间复杂度O(n
      
      </p>
      
      <p>
          <a href="/2021/08/05/560. 和为K的子数组/" class="excerpt-link">Read More...</a>
      </p>
      
    </section>
  </article>
  
  <article class="post">
    <header class="post-header">
      <span class="post-meta">
      <time datetime="2021-08-05T08:01:13.778Z" itemprop="datePublished">
          2021-08-05
      </time>
    
</span>
      <h2 class="post-title"><a href="/2021/08/05/394. 字符串解码/"></a></h2>
    </header>
    <section class="post-excerpt">
      <p>
      
        394. 字符串解码123456789101112131415161718192021222324252627282930313233343536public string DecodeString(string s)        &#123;            LinkedList&lt;int&gt; numberStack &#x3D; new LinkedList&lt;int&gt;();            Link
      
      </p>
      
      <p>
          <a href="/2021/08/05/394. 字符串解码/" class="excerpt-link">Read More...</a>
      </p>
      
    </section>
  </article>
  
  <article class="post">
    <header class="post-header">
      <span class="post-meta">
      <time datetime="2021-08-05T08:01:13.768Z" itemprop="datePublished">
          2021-08-05
      </time>
    
</span>
      <h2 class="post-title"><a href="/2021/08/05/236. 二叉树的最近公共祖先/"></a></h2>
    </header>
    <section class="post-excerpt">
      <p>
      
        236. 二叉树的最近公共祖先给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

12345678910示例 1:输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x
      
      </p>
      
      <p>
          <a href="/2021/08/05/236. 二叉树的最近公共祖先/" class="excerpt-link">Read More...</a>
      </p>
      
    </section>
  </article>
  
  <article class="post">
    <header class="post-header">
      <span class="post-meta">
      <time datetime="2021-08-05T08:01:13.754Z" itemprop="datePublished">
          2021-08-05
      </time>
    
</span>
      <h2 class="post-title"><a href="/2021/08/05/221. 最大正方形/"></a></h2>
    </header>
    <section class="post-excerpt">
      <p>
      
        221. 最大正方形在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。
示例:
12345678输入: 1 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0输出: 4
动态规划
若形成正方形（非单 1），以当前为右下角的视角看，则需要：当前格、上、左、左上都是 1
可以换个角度：当前格、上、左、左上都不能受 0 的限制，才能成为正方形


当前格可形成的大小可化简为当前格的左上、左、
      
      </p>
      
      <p>
          <a href="/2021/08/05/221. 最大正方形/" class="excerpt-link">Read More...</a>
      </p>
      
    </section>
  </article>
  
  <article class="post">
    <header class="post-header">
      <span class="post-meta">
      <time datetime="2021-08-05T08:01:13.740Z" itemprop="datePublished">
          2021-08-05
      </time>
    
</span>
      <h2 class="post-title"><a href="/2021/08/05/155. 最小栈/"></a></h2>
    </header>
    <section class="post-excerpt">
      <p>
      
        155. 最小栈设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。

push(x) —— 将元素 x 推入栈中。
pop() —— 删除栈顶的元素。
top() —— 获取栈顶元素。
getMin() —— 检索栈中的最小元素。

12345678910111213141516输入：[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&qu
      
      </p>
      
      <p>
          <a href="/2021/08/05/155. 最小栈/" class="excerpt-link">Read More...</a>
      </p>
      
    </section>
  </article>
  
  <article class="post">
    <header class="post-header">
      <span class="post-meta">
      <time datetime="2021-08-05T08:01:13.725Z" itemprop="datePublished">
          2021-08-05
      </time>
    
</span>
      <h2 class="post-title"><a href="/2021/08/05/136. 只出现一次的数字/"></a></h2>
    </header>
    <section class="post-excerpt">
      <p>
      
        136. 只出现一次的数字给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
说明：
你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？
12345678示例 1:输入: [2,2,1]输出: 1示例 2:输入: [4,1,2,1,2]输出: 4
思路：

使用暴力算法，时间复杂度O(n²)

使用排序，复杂度O(n*log(n))

使用哈希表，需要空间来存储之前的数，
      
      </p>
      
      <p>
          <a href="/2021/08/05/136. 只出现一次的数字/" class="excerpt-link">Read More...</a>
      </p>
      
    </section>
  </article>
  
  <article class="post">
    <header class="post-header">
      <span class="post-meta">
      <time datetime="2021-08-05T08:01:13.716Z" itemprop="datePublished">
          2021-08-05
      </time>
    
</span>
      <h2 class="post-title"><a href="/2021/08/05/121. 买卖股票的最佳时机/"></a></h2>
    </header>
    <section class="post-excerpt">
      <p>
      
        121. 买卖股票的最佳时机给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。
注意：你不能在买入股票前卖出股票。
示例 1:
输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。     注意利润不能是 
      
      </p>
      
      <p>
          <a href="/2021/08/05/121. 买卖股票的最佳时机/" class="excerpt-link">Read More...</a>
      </p>
      
    </section>
  </article>
  
  <article class="post">
    <header class="post-header">
      <span class="post-meta">
      <time datetime="2021-08-05T08:01:13.697Z" itemprop="datePublished">
          2021-08-05
      </time>
    
</span>
      <h2 class="post-title"><a href="/2021/08/05/102. 二叉树的层序遍历/"></a></h2>
    </header>
    <section class="post-excerpt">
      <p>
      
        102. 二叉树的层序遍历给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。
示例：二叉树：[3,9,20,null,null,15,7],
123456789101112    3   &#x2F; \  9  20    &#x2F;  \   15   7返回其层次遍历结果：[  [3],  [9,20],  [15,7]]


广度优先BFS思路：遍历每一层，然后将每层的数值存入List
      
      </p>
      
      <p>
          <a href="/2021/08/05/102. 二叉树的层序遍历/" class="excerpt-link">Read More...</a>
      </p>
      
    </section>
  </article>
  
  <article class="post">
    <header class="post-header">
      <span class="post-meta">
      <time datetime="2021-08-05T08:01:13.682Z" itemprop="datePublished">
          2021-08-05
      </time>
    
</span>
      <h2 class="post-title"><a href="/2021/08/05/98. 验证二叉搜索树/"></a></h2>
    </header>
    <section class="post-excerpt">
      <p>
      
        98. 验证二叉搜索树给定一个二叉树，判断其是否是一个有效的二叉搜索树。
假设一个二叉搜索树具有如下特征：
节点的左子树只包含小于当前节点的数。节点的右子树只包含大于当前节点的数。所有左子树和右子树自身必须也是二叉搜索树。示例 1:
12345输入:    2   &#x2F; \  1   3输出: true
示例 2:
123456789输入:    5   &#x2F; \  1   4     &#x2F; \    3   6
      
      </p>
      
      <p>
          <a href="/2021/08/05/98. 验证二叉搜索树/" class="excerpt-link">Read More...</a>
      </p>
      
    </section>
  </article>
  
  <article class="post">
    <header class="post-header">
      <span class="post-meta">
      <time datetime="2021-08-05T08:01:13.669Z" itemprop="datePublished">
          2021-08-05
      </time>
    
</span>
      <h2 class="post-title"><a href="/2021/08/05/70. 爬楼梯（动态规划）/"></a></h2>
    </header>
    <section class="post-excerpt">
      <p>
      
        70. 爬楼梯（动态规划）假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
注意：给定 n 是一个正整数。
示例 1：
输入： 2输出： 2解释： 有两种方法可以爬到楼顶。

 1 阶 + 1 阶
 2 阶示例 2：

输入： 3输出： 3解释： 有三种方法可以爬到楼顶。

 1 阶 + 1 阶 + 1 阶
 1 阶 + 2 阶
 2 阶 + 1 阶

来源：力扣（L
      
      </p>
      
      <p>
          <a href="/2021/08/05/70. 爬楼梯（动态规划）/" class="excerpt-link">Read More...</a>
      </p>
      
    </section>
  </article>
  
  <article class="post">
    <header class="post-header">
      <span class="post-meta">
      <time datetime="2021-08-05T08:01:13.654Z" itemprop="datePublished">
          2021-08-05
      </time>
    
</span>
      <h2 class="post-title"><a href="/2021/08/05/53. Maximum Subarray最大子序和/"></a></h2>
    </header>
    <section class="post-excerpt">
      <p>
      
        53. Maximum Subarray最大子序和给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
示例:
输入: [-2,1,-3,4,-1,2,1,-5,4],输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。进阶:
如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。
来源：力扣（LeetCode）链接：https://leetcode-
      
      </p>
      
      <p>
          <a href="/2021/08/05/53. Maximum Subarray最大子序和/" class="excerpt-link">Read More...</a>
      </p>
      
    </section>
  </article>
  
  <article class="post">
    <header class="post-header">
      <span class="post-meta">
      <time datetime="2021-08-05T08:01:13.636Z" itemprop="datePublished">
          2021-08-05
      </time>
    
</span>
      <h2 class="post-title"><a href="/2021/08/05/50. Pow(x, n)/"></a></h2>
    </header>
    <section class="post-excerpt">
      <p>
      
        50. Pow(x, n)实现 pow(x, n) ，即计算 x 的 n 次幂函数。
1234567891011121314151617示例 1:输入: 2.00000, 10输出: 1024.00000示例 2:输入: 2.10000, 3输出: 9.26100示例 3:输入: 2.00000, -2输出: 0.25000解释: 2-2 &#x3D; 1&#x2F;22 &#x3D; 1&#x2F;4 &#x3D; 0.25说明:-1
      
      </p>
      
      <p>
          <a href="/2021/08/05/50. Pow(x, n)/" class="excerpt-link">Read More...</a>
      </p>
      
    </section>
  </article>
  
  <article class="post">
    <header class="post-header">
      <span class="post-meta">
      <time datetime="2021-08-05T08:01:13.622Z" itemprop="datePublished">
          2021-08-05
      </time>
    
</span>
      <h2 class="post-title"><a href="/2021/08/05/34. 在排序数组中查找元素的第一个和最后一个位置/"></a></h2>
    </header>
    <section class="post-excerpt">
      <p>
      
        34. 在排序数组中查找元素的第一个和最后一个位置给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。
你的算法时间复杂度必须是 O(log n) 级别。
如果数组中不存在目标值，返回 [-1, -1]。
示例 1:
输入: nums = [5,7,7,8,8,10], target = 8输出: [3,4]示例 2:
输入: nums = [5,7,7,8,8,10], t
      
      </p>
      
      <p>
          <a href="/2021/08/05/34. 在排序数组中查找元素的第一个和最后一个位置/" class="excerpt-link">Read More...</a>
      </p>
      
    </section>
  </article>
  
  <article class="post">
    <header class="post-header">
      <span class="post-meta">
      <time datetime="2021-08-05T08:01:13.609Z" itemprop="datePublished">
          2021-08-05
      </time>
    
</span>
      <h2 class="post-title"><a href="/2021/08/05/25. K个一组翻转链表/"></a></h2>
    </header>
    <section class="post-excerpt">
      <p>
      
        25. K个一组翻转链表给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。
k 是一个正整数，它的值小于或等于链表的长度。
如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。
示例：
给你这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5
当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5
当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&
      
      </p>
      
      <p>
          <a href="/2021/08/05/25. K个一组翻转链表/" class="excerpt-link">Read More...</a>
      </p>
      
    </section>
  </article>
  
  <article class="post">
    <header class="post-header">
      <span class="post-meta">
      <time datetime="2021-08-05T08:01:13.597Z" itemprop="datePublished">
          2021-08-05
      </time>
    
</span>
      <h2 class="post-title"><a href="/2021/08/05/21. 合并两个有序链表/"></a></h2>
    </header>
    <section class="post-excerpt">
      <p>
      
        21. 合并两个有序链表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&#x2F;** * Definition for singly-linked list. * public class ListNode &#123; *     public int val; *     public ListNod
      
      </p>
      
      <p>
          <a href="/2021/08/05/21. 合并两个有序链表/" class="excerpt-link">Read More...</a>
      </p>
      
    </section>
  </article>
  
  <article class="post">
    <header class="post-header">
      <span class="post-meta">
      <time datetime="2021-08-05T08:01:13.580Z" itemprop="datePublished">
          2021-08-05
      </time>
    
</span>
      <h2 class="post-title"><a href="/2021/08/05/5. 最长回文子串/"></a></h2>
    </header>
    <section class="post-excerpt">
      <p>
      
        5. 最长回文子串给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。
示例 1：
123输入: &quot;babad&quot;输出: &quot;bab&quot;注意: &quot;aba&quot; 也是一个有效答案。
示例 2：
12输入: &quot;cbbd&quot;输出: &quot;bb&quot;


中心扩散法把每一位当成对称轴查找最长回文。时间复杂度：O(n²）O(n²），
      
      </p>
      
      <p>
          <a href="/2021/08/05/5. 最长回文子串/" class="excerpt-link">Read More...</a>
      </p>
      
    </section>
  </article>
  
  <article class="post">
    <header class="post-header">
      <span class="post-meta">
      <time datetime="2021-08-05T08:01:13.572Z" itemprop="datePublished">
          2021-08-05
      </time>
    
</span>
      <h2 class="post-title"><a href="/2021/08/05/3. 无重复字符的最长子串/"></a></h2>
    </header>
    <section class="post-excerpt">
      <p>
      
        3. 无重复字符的最长子串给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。
示例 1:
输入: “abcabcbb”输出: 3解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。示例 2:
输入: “bbbbb”输出: 1解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。示例 3:
输入: “pwwkew”输出: 3解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。     请注
      
      </p>
      
      <p>
          <a href="/2021/08/05/3. 无重复字符的最长子串/" class="excerpt-link">Read More...</a>
      </p>
      
    </section>
  </article>
  
  <article class="post">
    <header class="post-header">
      <span class="post-meta">
      <time datetime="2021-08-05T08:01:13.560Z" itemprop="datePublished">
          2021-08-05
      </time>
    
</span>
      <h2 class="post-title"><a href="/2021/08/05/2. 两数相加/"></a></h2>
    </header>
    <section class="post-excerpt">
      <p>
      
        2. 两数相加给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。
如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。
您可以假设除了数字 0 之外，这两个数都不会以 0 开头。
示例：
123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 4
      
      </p>
      
      <p>
          <a href="/2021/08/05/2. 两数相加/" class="excerpt-link">Read More...</a>
      </p>
      
    </section>
  </article>
  
  <article class="post">
    <header class="post-header">
      <span class="post-meta">
      <time datetime="2021-08-05T08:01:13.557Z" itemprop="datePublished">
          2021-08-05
      </time>
    
</span>
      <h2 class="post-title"><a href="/2021/08/05/1. 两数之和/"></a></h2>
    </header>
    <section class="post-excerpt">
      <p>
      
        1. 两数之和难度简单11506
给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
你可以按任意顺序返回答案。
示例 1：
123输入：nums &#x3D; [2,7,11,15], target &#x3D; 9输出：[0,1]解释：因为 nums[0] 
      
      </p>
      
      <p>
          <a href="/2021/08/05/1. 两数之和/" class="excerpt-link">Read More...</a>
      </p>
      
    </section>
  </article>
  
  <article class="post">
    <header class="post-header">
      <span class="post-meta">
      <time datetime="2021-08-05T08:01:13.554Z" itemprop="datePublished">
          2021-08-05
      </time>
    
</span>
      <h2 class="post-title"><a href="/2021/08/05/面试题64. 求1+2+…+n/"></a></h2>
    </header>
    <section class="post-excerpt">
      <p>
      
        面试题64. 求1+2+…+n求 1+2+…+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。
示例 1：
输入: n = 3输出: 6示例 2：
输入: n = 9输出: 45
限制：
1 &lt;= n &lt;= 10000
来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/qiu-12n-lcof著作权归
      
      </p>
      
      <p>
          <a href="/2021/08/05/面试题64. 求1+2+…+n/" class="excerpt-link">Read More...</a>
      </p>
      
    </section>
  </article>
  
  <article class="post">
    <header class="post-header">
      <span class="post-meta">
      <time datetime="2021-08-05T08:01:13.551Z" itemprop="datePublished">
          2021-08-05
      </time>
    
</span>
      <h2 class="post-title"><a href="/2021/08/05/国王和金矿，动态规划/"></a></h2>
    </header>
    <section class="post-excerpt">
      <p>
      
        国王和金矿有一个国家发现了5座金矿，每座金矿的黄金储量不同，需要参与挖掘的工人数也不同。参与挖矿工人的总数是10人。每座金矿要么全挖，要么不挖，不能派出一半人挖取一半金矿。要求用程序求解出，要想得到尽可能多的黄金，应该选择挖取哪几座金矿？

最优子结构5矿10工人的最优子结构为4矿10工人与4矿7工人+5矿收益的最大值。
F(5, 10) = MAX( F(4, 10), F(4, 10 - P[4]) + G[4] )
边界边界为只有
      
      </p>
      
      <p>
          <a href="/2021/08/05/国王和金矿，动态规划/" class="excerpt-link">Read More...</a>
      </p>
      
    </section>
  </article>
  
  <article class="post">
    <header class="post-header">
      <span class="post-meta">
      <time datetime="2021-08-05T08:01:13.542Z" itemprop="datePublished">
          2021-08-05
      </time>
    
</span>
      <h2 class="post-title"><a href="/2021/08/05/1395. 统计作战单位数/"></a></h2>
    </header>
    <section class="post-excerpt">
      <p>
      
        1395. 统计作战单位数n 名士兵站成一排。每个士兵都有一个 独一无二 的评分 rating 。
每 3 个士兵可以组成一个作战单位，分组规则如下：
从队伍中选出下标分别为 i、j、k 的 3 名士兵，他们的评分分别为 rating[i]、rating[j]、rating[k]作战单位需满足： rating[i] &lt; rating[j] &lt; rating[k] 或者 rating[i] &gt; rating[j] &gt
      
      </p>
      
      <p>
          <a href="/2021/08/05/1395. 统计作战单位数/" class="excerpt-link">Read More...</a>
      </p>
      
    </section>
  </article>
  
  <article class="post">
    <header class="post-header">
      <span class="post-meta">
      <time datetime="2021-08-05T08:01:13.531Z" itemprop="datePublished">
          2021-08-05
      </time>
    
</span>
      <h2 class="post-title"><a href="/2021/08/05/1365. 有多少小于当前数字的数字/"></a></h2>
    </header>
    <section class="post-excerpt">
      <p>
      
        1365. 有多少小于当前数字的数字给你一个数组 nums，对于其中每个元素 nums[i]，请你统计数组中比它小的所有数字的数目。
换而言之，对于每个 nums[i] 你必须计算出有效的 j 的数量，其中 j 满足 j != i 且 nums[j] &lt; nums[i] 。
以数组形式返回答案。
123456789101112131415161718示例 1：输入：nums &#x3D; [8,1,2,2,3]输出：[4,0,1,
      
      </p>
      
      <p>
          <a href="/2021/08/05/1365. 有多少小于当前数字的数字/" class="excerpt-link">Read More...</a>
      </p>
      
    </section>
  </article>
  
  <article class="post">
    <header class="post-header">
      <span class="post-meta">
      <time datetime="2021-08-05T08:01:13.520Z" itemprop="datePublished">
          2021-08-05
      </time>
    
</span>
      <h2 class="post-title"><a href="/2021/08/05/983. 最低票价/"></a></h2>
    </header>
    <section class="post-excerpt">
      <p>
      
        983. 最低票价在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 days 的数组给出。每一项是一个从 1 到 365 的整数。
火车票有三种不同的销售方式：
一张为期一天的通行证售价为 costs[0] 美元；一张为期七天的通行证售价为 costs[1] 美元；一张为期三十天的通行证售价为 costs[2] 美元。通行证允许数天无限制的旅行。 例如，如果我们在第 2 天获得一张
      
      </p>
      
      <p>
          <a href="/2021/08/05/983. 最低票价/" class="excerpt-link">Read More...</a>
      </p>
      
    </section>
  </article>
  
  <article class="post">
    <header class="post-header">
      <span class="post-meta">
      <time datetime="2021-08-05T08:01:13.510Z" itemprop="datePublished">
          2021-08-05
      </time>
    
</span>
      <h2 class="post-title"><a href="/2021/08/05/974. 和可被K整除的子数组/"></a></h2>
    </header>
    <section class="post-excerpt">
      <p>
      
        974. 和可被K整除的子数组复杂度O(n²)，会超时
12345678910111213141516171819202122232425262728public int SubarraysDivByK(int[] A, int K)        &#123;            int result = 0;            List&lt;List&lt;int&gt;&gt; doubleList = new List&
      
      </p>
      
      <p>
          <a href="/2021/08/05/974. 和可被K整除的子数组/" class="excerpt-link">Read More...</a>
      </p>
      
    </section>
  </article>
  
  <article class="post">
    <header class="post-header">
      <span class="post-meta">
      <time datetime="2021-08-05T08:01:13.499Z" itemprop="datePublished">
          2021-08-05
      </time>
    
</span>
      <h2 class="post-title"><a href="/2021/08/05/802. 找到最终的安全状态/"></a></h2>
    </header>
    <section class="post-excerpt">
      <p>
      
        802. 找到最终的安全状态难度中等
在有向图中，以某个节点为起始节点，从该点出发，每一步沿着图中的一条有向边行走。如果到达的节点是终点（即它没有连出的有向边），则停止。
对于一个起始节点，如果从该节点出发，无论每一步选择沿哪条有向边行走，最后必然在有限步内到达终点，则将该起始节点称作是 安全 的。
返回一个由图中所有安全的起始节点组成的数组作为答案。答案数组中的元素应当按 升序 排列。
该有向图有 n 个节点，按 0 到 n - 1 
      
      </p>
      
      <p>
          <a href="/2021/08/05/802. 找到最终的安全状态/" class="excerpt-link">Read More...</a>
      </p>
      
    </section>
  </article>
  
  <article class="post">
    <header class="post-header">
      <span class="post-meta">
      <time datetime="2021-01-19T06:24:43.741Z" itemprop="datePublished">
          2021-01-19
      </time>
    
</span>
      <h2 class="post-title"><a href="/2021/01/19/hello-world/">Hello World</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
      
        Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.
Quick StartCreate a new p
      
      </p>
      
      <p>
          <a href="/2021/01/19/hello-world/" class="excerpt-link">Read More...</a>
      </p>
      
    </section>
  </article>
  
  <article class="post">
    <header class="post-header">
      <span class="post-meta">
      <time datetime="2021-01-11T08:04:53.000Z" itemprop="datePublished">
          2021-01-11
      </time>
    
</span>
      <h2 class="post-title"><a href="/2021/01/11/如何使用Git管理项目/">如何使用Git管理项目？</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
      
        
为什么使用Git？
多人协作使用
单人使用时，进行版本管理



0. 最简单的入门教程：
git - 简明指南 https://www.runoob.com/manual/git-guide/

如果想更详细的学习，可以参考：

廖雪峰的官方网站 https://www.liaoxuefeng.com/wiki/896043488029600
Git官方网站 http://git-scm.com/
Github官方文档 https:
      
      </p>
      
      <p>
          <a href="/2021/01/11/如何使用Git管理项目/" class="excerpt-link">Read More...</a>
      </p>
      
    </section>
  </article>
  
  <article class="post">
    <header class="post-header">
      <span class="post-meta">
      <time datetime="2020-06-27T10:06:53.000Z" itemprop="datePublished">
          2020-06-27
      </time>
    
</span>
      <h2 class="post-title"><a href="/2020/06/27/quiry-binary/">查询二进制树防碰撞仿真程序 说明文档</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
      
        环境依赖在使用本程序之前，请配置好Java环境。推荐版本：
java version “13.0.2” 2020-01-14Java(TM) SE Runtime Environment (build 13.0.2+8)Java HotSpot(TM) 64-Bit Server VM (build 13.0.2+8, mixed mode, sharing)
本程序使用了以下库 ，您也可以在源代码中查看：
123import java
      
      </p>
      
      <p>
          <a href="/2020/06/27/quiry-binary/" class="excerpt-link">Read More...</a>
      </p>
      
    </section>
  </article>
  
  <article class="post">
    <header class="post-header">
      <span class="post-meta">
      <time datetime="2020-06-14T12:10:53.000Z" itemprop="datePublished">
          2020-06-14
      </time>
    
</span>
      <h2 class="post-title"><a href="/2020/06/14/Design-Patterns/">Design Patterns 设计模式</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
      
        设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的；设计模式使代码编制真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。
Decorator pattern 装饰模式一个类包含一个接口。
Adapter pattern 适配器模式是作为两个不兼容的接口之
      
      </p>
      
      <p>
          <a href="/2020/06/14/Design-Patterns/" class="excerpt-link">Read More...</a>
      </p>
      
    </section>
  </article>
  
  <article class="post">
    <header class="post-header">
      <span class="post-meta">
      <time datetime="2020-06-02T12:34:53.000Z" itemprop="datePublished">
          2020-06-02
      </time>
    
</span>
      <h2 class="post-title"><a href="/2020/06/02/贝叶斯分类法/">贝叶斯分类法</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
      
        贝叶斯分类法是一种分类算法的总称，以贝叶斯定理（后验定理）为基础。
0. 贝叶斯定理贝叶斯公式 为：
1. 分类问题综述数学上，分类问题可定义为：$$已知类别集合C=y1,y2,…yn，其中每一个元素是一个类别，以及项集合（特征集合）$$
$$I=x1,x2,…xn，其中每个元素为一个待分类项。确定映射规则$$
$$y=f(X)，使得任意xi∈有且只有一个yi∈C，使得yi∈f(xi)成立。$$
函数f又叫分类器，而分类算法的任务就是构
      
      </p>
      
      <p>
          <a href="/2020/06/02/贝叶斯分类法/" class="excerpt-link">Read More...</a>
      </p>
      
    </section>
  </article>
  
  <article class="post">
    <header class="post-header">
      <span class="post-meta">
      <time datetime="2020-04-12T08:33:53.000Z" itemprop="datePublished">
          2020-04-12
      </time>
    
</span>
      <h2 class="post-title"><a href="/2020/04/12/委托与事件学习笔记/">C#委托与事件学习笔记</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
      
        C# 语言中的委托（delegate）和事件（event）是其一大特色，委托和事件在 Windows 窗体应用程序、 ASP.NET 应用程序、WPF 应用程序等应用中是最为普遍的应用。
通过定义委托和事件可以方便方法重用，并提高程序的编写效率。
C# 中的委托类似于 C 或 C++ 中函数的指针。委托是存有对某个方法的引用的一种引用类型变量。引用可在运行时被改变。
事件基本上说是一个用户操作，如按键、点击、鼠标移动等等，或者是一些出现
      
      </p>
      
      <p>
          <a href="/2020/04/12/委托与事件学习笔记/" class="excerpt-link">Read More...</a>
      </p>
      
    </section>
  </article>
  
  <nav class="pagination" role="pagination">
    
    <span class="page-number">Page 1 of 1</span>
    
  </nav>
</main>


  
<footer class="site-footer">
  
  <div class="inner">
     <section class="copyright">All content copyright <a href="/">Max's blog</a> &copy; 2014 &bull; All rights reserved.</section>
     <section class="poweredby">Proudly published with <a class="icon-ghost" target="_blank" rel="noopener" href="http://zespia.tw/hexo/">Hexo</a></section>
  </div>
</footer>

  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>

<script type="text/javascript" src="/js/jquery.fitvids.js"></script>
<script type="text/javascript" src="/js/index.js"></script>






</body>
</html>
